// Generated by CoffeeScript 1.6.3
var Q, fs, level, mapHash, readDB, writeDB, zipmap;

Q = require('q');

fs = require('fs');

level = require('level');

readDB = function(db, key) {
  var deferred;
  deferred = Q.defer();
  db.get(key, function(err, val) {
    if (!err) {
      return deferred.resolve(val);
    } else if (err.notFound) {
      return deferred.resolve({});
    } else {
      return deferred.reject(err);
    }
  });
  return deferred.promise;
};

writeDB = function(db, key, val) {
  return Q.ninvoke(db, 'put', key, val);
};

mapHash = function(h, f) {
  var key, val, _results;
  _results = [];
  for (key in h) {
    val = h[key];
    _results.push(f(key, val));
  }
  return _results;
};

zipmap = function(keys, values) {
  var i, result, _i, _ref;
  result = {};
  for (i = _i = 0, _ref = Math.min(keys.length, values.length); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    result[keys[i]] = values[i];
  }
  return result;
};

module.exports = function(path, cb) {
  var db, withdb;
  withdb = function(f) {
    return Q.nfcall(level, path, {
      valueEncoding: 'json'
    }).then(function(db) {
      return f(db).fin(function() {
        return Q.ninvoke(db, 'close');
      });
    });
  };
  db = {
    readDependencyGraph: function(cb) {
      return withdb(function(db) {
        return readDB(db, 'predecessors');
      }).nodeify(cb);
    },
    writeDependencyGraph: function(val, cb) {
      return withdb(function(db) {
        return writeDB(db, 'predecessors', val);
      }).nodeify(cb);
    },
    readSomeHeaders: function(keys, cb) {
      return withdb(function(db) {
        return Q.all(keys.map(function(key) {
          return readDB(db, "headers-" + key);
        })).then(function(values) {
          return zipmap(keys, values);
        });
      }).nodeify(cb);
    },
    writeSomeHeaders: function(data, cb) {
      return withdb(function(db) {
        return mapHash(data, function(key, val) {
          return function() {
            return writeDB(db, "headers-" + key, val);
          };
        }).reduce(Q.when, Q());
      }).nodeify(cb);
    },
    readSomeDeviations: function(keys, cb) {
      return withdb(function(db) {
        return Q.all(keys.map(function(key) {
          return readDB(db, "deviations-" + key);
        })).then(function(values) {
          return zipmap(keys, values);
        });
      }).nodeify(cb);
    },
    writeSomeDeviations: function(data, cb) {
      return withdb(function(db) {
        return mapHash(data, function(key, val) {
          return function() {
            return writeDB(db, "deviations-" + key, val);
          };
        }).reduce(Q.when, Q());
      }).nodeify(cb);
    },
    readSingleNodeDetails: function(key, cb) {
      return withdb(function(db) {
        return readDB(db, "details-" + key);
      }).nodeify(cb);
    },
    writeSingleNodeDetails: function(key, data, cb) {
      return withdb(function(db) {
        return writeDB(db, "details-" + key, data);
      }).nodeify(cb);
    }
  };
  return cb(null, db);
};
