// Generated by CoffeeScript 1.6.3
var Q, any, createTable, fs, readTable, writeTable;

Q = require('q');

fs = require('fs');

any = require('any-db');

createTable = function(db, name) {
  return Q.ninvoke(db, "query", "CREATE TABLE " + name + " (id text PRIMARY KEY, content text)");
};

readTable = function(db, name, keys) {
  var keylist, query;
  if (keys != null) {
    keylist = keys.map(function(s) {
      return "'" + s + "'";
    }).join(", ");
    query = "SELECT * FROM " + name + " WHERE id IN (" + keylist + ")";
  } else {
    query = "SELECT * FROM " + name;
  }
  return Q.ninvoke(db, "query", query).then(function(response) {
    var k, r, result, _i, _j, _len, _len1, _ref;
    result = {};
    _ref = response.rows;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      r = _ref[_i];
      result[r.id] = JSON.parse(r.content);
    }
    if (keys != null) {
      for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
        k = keys[_j];
        if (result[k] == null) {
          result[k] = {};
        }
      }
    }
    return result;
  });
};

writeTable = function(db, name, data) {
  var key, state, val, _fn;
  state = Q.fcall(function() {});
  _fn = function(key, val) {
    return state = state.then(function() {
      return Q.ninvoke(db, "query", "INSERT OR REPLACE INTO " + name + " VALUES (?, ?)", [key, JSON.stringify(val)]);
    });
  };
  for (key in data) {
    val = data[key];
    _fn(key, val);
  }
  return state;
};

module.exports = function(path, cb) {
  var storage, withdb;
  withdb = function(f) {
    return Q.nfcall(any.createConnection, "sqlite3://" + path).then(function(db) {
      return f(db).fin(function() {
        return Q.ninvoke(db, 'end');
      });
    });
  };
  storage = {
    readDependencyGraph: function(cb) {
      return withdb(function(db) {
        return readTable(db, 'predecessors');
      }).nodeify(cb);
    },
    writeDependencyGraph: function(val, cb) {
      return withdb(function(db) {
        return writeTable(db, 'predecessors', val);
      }).nodeify(cb);
    },
    readSomeHeaders: function(keys, cb) {
      return withdb(function(db) {
        return readTable(db, 'headers', keys);
      }).nodeify(cb);
    },
    writeSomeHeaders: function(data, cb) {
      return withdb(function(db) {
        return writeTable(db, 'headers', data);
      }).nodeify(cb);
    },
    readSomeDeviations: function(keys, cb) {
      return withdb(function(db) {
        return readTable(db, 'deviations', keys);
      }).nodeify(cb);
    },
    writeSomeDeviations: function(data, cb) {
      return withdb(function(db) {
        return writeTable(db, 'deviations', data);
      }).nodeify(cb);
    },
    readSingleNodeDetails: function(key, cb) {
      return withdb(function(db) {
        return readTable(db, 'details', [key]);
      }).then(function(data) {
        return data[key];
      }).nodeify(cb);
    },
    writeSingleNodeDetails: function(key, val, cb) {
      var data;
      data = {};
      data[key] = val;
      return withdb(function(db) {
        return writeTable(db, 'details', data);
      }).nodeify(cb);
    }
  };
  return fs.exists(path, function(exists) {
    if (exists) {
      return cb(null, storage);
    } else {
      return withdb(function(db) {
        return createTable(db, 'predecessors').then(function() {
          return createTable(db, 'headers');
        }).then(function() {
          return createTable(db, 'details');
        }).then(function() {
          return createTable(db, 'deviations');
        });
      }).then(function() {
        return cb(null, storage);
      }).fail(cb);
    }
  });
};
